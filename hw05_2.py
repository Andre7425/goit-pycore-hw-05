

import re
from typing import Callable, Iterable, Iterator

def generator_numbers(text: str) -> Iterator[float]:
    """
    Повертає генератор усіх чисел з тексту.
    За умовою числа обов'язково мають пробіли з обох боків.
    Щоб коректно спрацювати на початку/кінці рядка, додаємо
    по одному пробілу зліва і справа.
    """
    #   (?<=\s)   — перед числом має бути пробіл
    #   \d+(?:\.\d+)? — ціле або з десятковою крапкою
    #   (?=\s)    — після числа має бути пробіл
    pattern = r'(?<=\s)\d+(?:\.\d+)?(?=\s)'

    for m in re.finditer(pattern, f" {text} "): # додаємо пробіли, якщо число стоїть на самому початку 
                                                # або в кінці рядка, фізично немає символа зліва/справа
        """ Шукає всі збіги регулярного виразу pattern у рядку.
            Повертає ітератор з об’єктами Match (на відміну від findall, 
            який одразу повертає список рядків). Це ощадніше по пам’яті й дає доступ 
            до .group(), .span(), .start(), .end()
        """
        yield float(m.group())  # рядок збігу -> в число і повертає, зберігаючи поточний стан


def sum_profit(text: str, func: Callable[[str], Iterable[float]]) -> float:
    """
    приймає перший параметр рядок text, другий параметр func "викликувана" функція, яка
    приймає рядок і повертає ітерований float
    Ця функція повертає суму всіх чисел у тексті(рядку), використовуючи передану
    функцію-генератор (наприклад, generator_numbers).
    """
    return sum(func(text))


# Приклад використання
if __name__ == "__main__":
    text = (
        "Загальний дохід працівника складається з декількох частин: "
        "1000.01 як основний дохід, доповнений додатковими надходженнями "
        "27.45 і 324.00 доларів."
    )
    total_income = sum_profit(text, generator_numbers)
    print(f"Загальний дохід: {total_income}")  # 1351.46
